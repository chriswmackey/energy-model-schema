============================= test session starts =============================
platform win32 -- Python 3.7.2, pytest-4.4.0, py-1.8.0, pluggy-0.9.0
rootdir: C:\Gitrepos\energy-model-schema
plugins: dependency-0.4.0
collected 11 items

tests\test_construction.py ....FF.FF..                                   [100%]

================================== FAILURES ===================================
_____________________________ test_windowglazing ______________________________

    def test_windowglazing():
>       EnergyWindowMaterialSimpleGlazSys.parse_obj(in_window_glazing)

tests\test_construction.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python37\lib\site-packages\pydantic\main.py:316: in parse_obj
    return cls(**obj)
C:\Python37\lib\site-packages\pydantic\main.py:228: in __init__
    object.__setattr__(self, '__values__', self._process_values(data))
C:\Python37\lib\site-packages\pydantic\main.py:428: in _process_values
    return validate_model(self, input_data)  # type: ignore
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

model = <[RecursionError("maximum recursion depth exceeded while calling a Python object") raised in repr()] EnergyWindowMaterialSimpleGlazSys object at 0x2553c7de2d0>
input_data = {'back_emissivity': 0.985, 'conductivity_glass': 2.1073, 'dirt_correlation': 1, 'front_emissivity': 0.985, ...}
raise_exc = True

    def validate_model(  # noqa: C901 (ignore complexity)
        model: Union[BaseModel, Type[BaseModel]], input_data: 'DictStrAny', raise_exc: bool = True
    ) -> Union['DictStrAny', Tuple['DictStrAny', Optional[ValidationError]]]:
        """
        validate data against a model.
        """
        values = {}
        errors = []
        names_used = set()
        config = model.__config__
        check_extra = config.extra is not Extra.ignore
    
        for name, field in model.__fields__.items():
            if type(field.type_) == ForwardRef:
                raise ConfigError(
                    f'field "{field.name}" not yet prepared so type is still a ForwardRef, '
                    f'you might need to call {model.__class__.__name__}.update_forward_refs().'
                )
    
            value = input_data.get(field.alias, _missing)
            using_name = False
            if value is _missing and config.allow_population_by_alias and field.alt_alias:
                value = input_data.get(field.name, _missing)
                using_name = True
    
            if value is _missing:
                if field.required:
                    errors.append(ErrorWrapper(MissingError(), loc=field.alias, config=model.__config__))
                    continue
                value = deepcopy(field.default)
                if not model.__config__.validate_all and not field.validate_always:
                    values[name] = value
                    continue
            elif check_extra:
                names_used.add(field.name if using_name else field.alias)
    
            v_, errors_ = field.validate(value, values, loc=field.alias, cls=model.__class__)  # type: ignore
            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[name] = v_
    
        if check_extra:
            extra = input_data.keys() - names_used
            if extra:
                if config.extra is Extra.allow:
                    for f in extra:
                        values[f] = input_data[f]
                else:
                    for f in sorted(extra):
                        errors.append(ErrorWrapper(ExtraError(), loc=f, config=config))
    
        if not raise_exc:
            return values, ValidationError(errors) if errors else None
    
        if errors:
>           raise ValidationError(errors)
E           pydantic.error_wrappers.ValidationError: 4 validation errors
E           type
E             value is not a valid enumeration member (type=type_error.enum)
E           name
E             string does not match regex "^[\s.A-Za-z0-9_-]*$" (type=value_error.str.regex; pattern=^[\s.A-Za-z0-9_-]*$)
E           u_factor
E             field required (type=value_error.missing)
E           SHGC
E             field required (type=value_error.missing)

C:\Python37\lib\site-packages\pydantic\main.py:623: ValidationError
______________________________ test_window_blind ______________________________

    def test_window_blind():
>       EnergyWindowMaterialBlind.parse_obj(in_window_blind)

tests\test_construction.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python37\lib\site-packages\pydantic\main.py:316: in parse_obj
    return cls(**obj)
C:\Python37\lib\site-packages\pydantic\main.py:228: in __init__
    object.__setattr__(self, '__values__', self._process_values(data))
C:\Python37\lib\site-packages\pydantic\main.py:428: in _process_values
    return validate_model(self, input_data)  # type: ignore
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

model = <[RecursionError("maximum recursion depth exceeded while calling a Python object") raised in repr()] EnergyWindowMaterialBlind object at 0x2553c7aedc8>
input_data = {'back_beam_solar_reflectance': 0.5, 'back_beam_visible_reflectance': 0.5, 'back_diffuse_solar_reflectance': 0.5, 'back_diffuse_visible_reflectance': 0.5, ...}
raise_exc = True

    def validate_model(  # noqa: C901 (ignore complexity)
        model: Union[BaseModel, Type[BaseModel]], input_data: 'DictStrAny', raise_exc: bool = True
    ) -> Union['DictStrAny', Tuple['DictStrAny', Optional[ValidationError]]]:
        """
        validate data against a model.
        """
        values = {}
        errors = []
        names_used = set()
        config = model.__config__
        check_extra = config.extra is not Extra.ignore
    
        for name, field in model.__fields__.items():
            if type(field.type_) == ForwardRef:
                raise ConfigError(
                    f'field "{field.name}" not yet prepared so type is still a ForwardRef, '
                    f'you might need to call {model.__class__.__name__}.update_forward_refs().'
                )
    
            value = input_data.get(field.alias, _missing)
            using_name = False
            if value is _missing and config.allow_population_by_alias and field.alt_alias:
                value = input_data.get(field.name, _missing)
                using_name = True
    
            if value is _missing:
                if field.required:
                    errors.append(ErrorWrapper(MissingError(), loc=field.alias, config=model.__config__))
                    continue
                value = deepcopy(field.default)
                if not model.__config__.validate_all and not field.validate_always:
                    values[name] = value
                    continue
            elif check_extra:
                names_used.add(field.name if using_name else field.alias)
    
            v_, errors_ = field.validate(value, values, loc=field.alias, cls=model.__class__)  # type: ignore
            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[name] = v_
    
        if check_extra:
            extra = input_data.keys() - names_used
            if extra:
                if config.extra is Extra.allow:
                    for f in extra:
                        values[f] = input_data[f]
                else:
                    for f in sorted(extra):
                        errors.append(ErrorWrapper(ExtraError(), loc=f, config=config))
    
        if not raise_exc:
            return values, ValidationError(errors) if errors else None
    
        if errors:
>           raise ValidationError(errors)
E           pydantic.error_wrappers.ValidationError: 1 validation error
E           back_infrared_hemispherical_emissivity
E             ensure this value is greater than or equal to 9 (type=value_error.number.not_ge; limit_value=9)

C:\Python37\lib\site-packages\pydantic\main.py:623: ValidationError
____________________________ test_cons_transparent ____________________________

    def test_cons_transparent():
>       EnergyConstructionTransparent.parse_obj(construction_window)

tests\test_construction.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python37\lib\site-packages\pydantic\main.py:316: in parse_obj
    return cls(**obj)
C:\Python37\lib\site-packages\pydantic\main.py:228: in __init__
    object.__setattr__(self, '__values__', self._process_values(data))
C:\Python37\lib\site-packages\pydantic\main.py:428: in _process_values
    return validate_model(self, input_data)  # type: ignore
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

model = <[RecursionError("maximum recursion depth exceeded while calling a Python object") raised in repr()] EnergyConstructionTransparent object at 0x2553c80b7e0>
input_data = {'materials': [{'back_emissivity': 0.985, 'conductivity_glass': 2.1073, 'dirt_correlation': 1, 'front_emissivity': 0.9..._correlation': 1, 'front_emissivity': 0.985, ...}], 'name': 'Exterior Window', 'type': 'EnergyConstructionTransparent'}
raise_exc = True

    def validate_model(  # noqa: C901 (ignore complexity)
        model: Union[BaseModel, Type[BaseModel]], input_data: 'DictStrAny', raise_exc: bool = True
    ) -> Union['DictStrAny', Tuple['DictStrAny', Optional[ValidationError]]]:
        """
        validate data against a model.
        """
        values = {}
        errors = []
        names_used = set()
        config = model.__config__
        check_extra = config.extra is not Extra.ignore
    
        for name, field in model.__fields__.items():
            if type(field.type_) == ForwardRef:
                raise ConfigError(
                    f'field "{field.name}" not yet prepared so type is still a ForwardRef, '
                    f'you might need to call {model.__class__.__name__}.update_forward_refs().'
                )
    
            value = input_data.get(field.alias, _missing)
            using_name = False
            if value is _missing and config.allow_population_by_alias and field.alt_alias:
                value = input_data.get(field.name, _missing)
                using_name = True
    
            if value is _missing:
                if field.required:
                    errors.append(ErrorWrapper(MissingError(), loc=field.alias, config=model.__config__))
                    continue
                value = deepcopy(field.default)
                if not model.__config__.validate_all and not field.validate_always:
                    values[name] = value
                    continue
            elif check_extra:
                names_used.add(field.name if using_name else field.alias)
    
            v_, errors_ = field.validate(value, values, loc=field.alias, cls=model.__class__)  # type: ignore
            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[name] = v_
    
        if check_extra:
            extra = input_data.keys() - names_used
            if extra:
                if config.extra is Extra.allow:
                    for f in extra:
                        values[f] = input_data[f]
                else:
                    for f in sorted(extra):
                        errors.append(ErrorWrapper(ExtraError(), loc=f, config=config))
    
        if not raise_exc:
            return values, ValidationError(errors) if errors else None
    
        if errors:
>           raise ValidationError(errors)
E           pydantic.error_wrappers.ValidationError: 64 validation errors
E           materials -> 0 -> type
E             value is not a valid enumeration member (type=type_error.enum)
E           materials -> 0 -> name
E             string does not match regex "^[\s.A-Za-z0-9_-]*$" (type=value_error.str.regex; pattern=^[\s.A-Za-z0-9_-]*$)
E           materials -> 0 -> conductivity_coeff_A
E             field required (type=value_error.missing)
E           materials -> 0 -> conductivity_coeff_B
E             field required (type=value_error.missing)
E           materials -> 0 -> conductivity_coeff_C
E             field required (type=value_error.missing)
E           materials -> 0 -> viscosity_coeff_A
E             field required (type=value_error.missing)
E           materials -> 0 -> viscosity_coeff_B
E             field required (type=value_error.missing)
E           materials -> 0 -> viscosity_coeff_C
E             field required (type=value_error.missing)
E           materials -> 0 -> specific_heat_coeff_A
E             field required (type=value_error.missing)
E           materials -> 0 -> specific_heat_coeff_B
E             field required (type=value_error.missing)
E           materials -> 0 -> specific_heat_coeff_C
E             field required (type=value_error.missing)
E           materials -> 0 -> specific_heat_ratio
E             field required (type=value_error.missing)
E           materials -> 0 -> molecular_weight
E             field required (type=value_error.missing)
E           materials -> 0 -> type
E             value is not a valid enumeration member (type=type_error.enum)
E           materials -> 0 -> name
E             string does not match regex "^[\s.A-Za-z0-9_-]*$" (type=value_error.str.regex; pattern=^[\s.A-Za-z0-9_-]*$)
E           materials -> 0 -> u_factor
E             field required (type=value_error.missing)
E           materials -> 0 -> SHGC
E             field required (type=value_error.missing)
E           materials -> 0 -> type
E             value is not a valid enumeration member (type=type_error.enum)
E           materials -> 0 -> slat_orientation
E             field required (type=value_error.missing)
E           materials -> 0 -> name
E             string does not match regex "^[\s.A-Za-z0-9_-]*$" (type=value_error.str.regex; pattern=^[\s.A-Za-z0-9_-]*$)
E           materials -> 0 -> name
E             string does not match regex "^[\s.A-Za-z0-9_-]*$" (type=value_error.str.regex; pattern=^[\s.A-Za-z0-9_-]*$)
E           materials -> 0 -> type
E             value is not a valid enumeration member (type=type_error.enum)
E           materials -> 0 -> name
E             string does not match regex "^[\s.A-Za-z0-9_-]*$" (type=value_error.str.regex; pattern=^[\s.A-Za-z0-9_-]*$)
E           materials -> 1 -> conductivity_coeff_A
E             field required (type=value_error.missing)
E           materials -> 1 -> conductivity_coeff_B
E             field required (type=value_error.missing)
E           materials -> 1 -> conductivity_coeff_C
E             field required (type=value_error.missing)
E           materials -> 1 -> viscosity_coeff_A
E             field required (type=value_error.missing)
E           materials -> 1 -> viscosity_coeff_B
E             field required (type=value_error.missing)
E           materials -> 1 -> viscosity_coeff_C
E             field required (type=value_error.missing)
E           materials -> 1 -> specific_heat_coeff_A
E             field required (type=value_error.missing)
E           materials -> 1 -> specific_heat_coeff_B
E             field required (type=value_error.missing)
E           materials -> 1 -> specific_heat_coeff_C
E             field required (type=value_error.missing)
E           materials -> 1 -> specific_heat_ratio
E             field required (type=value_error.missing)
E           materials -> 1 -> molecular_weight
E             field required (type=value_error.missing)
E           materials -> 1 -> type
E             value is not a valid enumeration member (type=type_error.enum)
E           materials -> 1 -> u_factor
E             field required (type=value_error.missing)
E           materials -> 1 -> SHGC
E             field required (type=value_error.missing)
E           materials -> 1 -> type
E             value is not a valid enumeration member (type=type_error.enum)
E           materials -> 1 -> slat_orientation
E             field required (type=value_error.missing)
E           materials -> 1 -> type
E             value is not a valid enumeration member (type=type_error.enum)
E           materials -> 1 -> type
E             value is not a valid enumeration member (type=type_error.enum)
E           materials -> 2 -> type
E             value is not a valid enumeration member (type=type_error.enum)
E           materials -> 2 -> name
E             string does not match regex "^[\s.A-Za-z0-9_-]*$" (type=value_error.str.regex; pattern=^[\s.A-Za-z0-9_-]*$)
E           materials -> 2 -> conductivity_coeff_A
E             field required (type=value_error.missing)
E           materials -> 2 -> conductivity_coeff_B
E             field required (type=value_error.missing)
E           materials -> 2 -> conductivity_coeff_C
E             field required (type=value_error.missing)
E           materials -> 2 -> viscosity_coeff_A
E             field required (type=value_error.missing)
E           materials -> 2 -> viscosity_coeff_B
E             field required (type=value_error.missing)
E           materials -> 2 -> viscosity_coeff_C
E             field required (type=value_error.missing)
E           materials -> 2 -> specific_heat_coeff_A
E             field required (type=value_error.missing)
E           materials -> 2 -> specific_heat_coeff_B
E             field required (type=value_error.missing)
E           materials -> 2 -> specific_heat_coeff_C
E             field required (type=value_error.missing)
E           materials -> 2 -> specific_heat_ratio
E             field required (type=value_error.missing)
E           materials -> 2 -> molecular_weight
E             field required (type=value_error.missing)
E           materials -> 2 -> type
E             value is not a valid enumeration member (type=type_error.enum)
E           materials -> 2 -> name
E             string does not match regex "^[\s.A-Za-z0-9_-]*$" (type=value_error.str.regex; pattern=^[\s.A-Za-z0-9_-]*$)
E           materials -> 2 -> u_factor
E             field required (type=value_error.missing)
E           materials -> 2 -> SHGC
E             field required (type=value_error.missing)
E           materials -> 2 -> type
E             value is not a valid enumeration member (type=type_error.enum)
E           materials -> 2 -> slat_orientation
E             field required (type=value_error.missing)
E           materials -> 2 -> name
E             string does not match regex "^[\s.A-Za-z0-9_-]*$" (type=value_error.str.regex; pattern=^[\s.A-Za-z0-9_-]*$)
E           materials -> 2 -> name
E             string does not match regex "^[\s.A-Za-z0-9_-]*$" (type=value_error.str.regex; pattern=^[\s.A-Za-z0-9_-]*$)
E           materials -> 2 -> type
E             value is not a valid enumeration member (type=type_error.enum)
E           materials -> 2 -> name
E             string does not match regex "^[\s.A-Za-z0-9_-]*$" (type=value_error.str.regex; pattern=^[\s.A-Za-z0-9_-]*$)

C:\Python37\lib\site-packages\pydantic\main.py:623: ValidationError
______________________________ test_cons_opaque _______________________________

    def test_cons_opaque():
>       EnergyConstructionOpaque.parse_obj(construction_internal_floor)

tests\test_construction.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Python37\lib\site-packages\pydantic\main.py:316: in parse_obj
    return cls(**obj)
C:\Python37\lib\site-packages\pydantic\main.py:228: in __init__
    object.__setattr__(self, '__values__', self._process_values(data))
C:\Python37\lib\site-packages\pydantic\main.py:428: in _process_values
    return validate_model(self, input_data)  # type: ignore
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

model = <[RecursionError("maximum recursion depth exceeded while calling a Python object") raised in repr()] EnergyConstructionOpaque object at 0x2553c823948>
input_data = {'materials': [{'name': 'CP02 Carpet Pad', 'r_value': 0.9, 'roughness': 'Smooth', 'solar_abosrptance': 0.8, ...}, {'co...': 2242, 'name': '8in Concrete HW', 'roughness': 'MediumRough', ...}], 'name': 'sample1', 'type': 'EnergyConstruction'}
raise_exc = True

    def validate_model(  # noqa: C901 (ignore complexity)
        model: Union[BaseModel, Type[BaseModel]], input_data: 'DictStrAny', raise_exc: bool = True
    ) -> Union['DictStrAny', Tuple['DictStrAny', Optional[ValidationError]]]:
        """
        validate data against a model.
        """
        values = {}
        errors = []
        names_used = set()
        config = model.__config__
        check_extra = config.extra is not Extra.ignore
    
        for name, field in model.__fields__.items():
            if type(field.type_) == ForwardRef:
                raise ConfigError(
                    f'field "{field.name}" not yet prepared so type is still a ForwardRef, '
                    f'you might need to call {model.__class__.__name__}.update_forward_refs().'
                )
    
            value = input_data.get(field.alias, _missing)
            using_name = False
            if value is _missing and config.allow_population_by_alias and field.alt_alias:
                value = input_data.get(field.name, _missing)
                using_name = True
    
            if value is _missing:
                if field.required:
                    errors.append(ErrorWrapper(MissingError(), loc=field.alias, config=model.__config__))
                    continue
                value = deepcopy(field.default)
                if not model.__config__.validate_all and not field.validate_always:
                    values[name] = value
                    continue
            elif check_extra:
                names_used.add(field.name if using_name else field.alias)
    
            v_, errors_ = field.validate(value, values, loc=field.alias, cls=model.__class__)  # type: ignore
            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[name] = v_
    
        if check_extra:
            extra = input_data.keys() - names_used
            if extra:
                if config.extra is Extra.allow:
                    for f in extra:
                        values[f] = input_data[f]
                else:
                    for f in sorted(extra):
                        errors.append(ErrorWrapper(ExtraError(), loc=f, config=config))
    
        if not raise_exc:
            return values, ValidationError(errors) if errors else None
    
        if errors:
>           raise ValidationError(errors)
E           pydantic.error_wrappers.ValidationError: 1 validation error
E           type
E             value is not a valid enumeration member (type=type_error.enum)

C:\Python37\lib\site-packages\pydantic\main.py:623: ValidationError
===================== 4 failed, 7 passed in 0.30 seconds ======================
